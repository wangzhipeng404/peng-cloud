"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkonline_conplier"] = self["webpackChunkonline_conplier"] || []).push([["node_modules_monaco-editor_esm_vs_basic-languages_protobuf_protobuf_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.js":
/*!********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"conf\": function() { return /* binding */ conf; },\n/* harmony export */   \"language\": function() { return /* binding */ language; }\n/* harmony export */ });\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n// src/basic-languages/protobuf/protobuf.ts\nvar namedLiterals = [\"true\", \"false\"];\nvar conf = {\n  comments: {\n    lineComment: \"//\",\n    blockComment: [\"/*\", \"*/\"]\n  },\n  brackets: [[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"], [\"<\", \">\"]],\n  surroundingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"<\",\n    close: \">\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }],\n  autoClosingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"<\",\n    close: \">\"\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: [\"string\"]\n  }, {\n    open: \"'\",\n    close: \"'\",\n    notIn: [\"string\"]\n  }],\n  autoCloseBefore: \".,=}])>' \\n\t\",\n  indentationRules: {\n    increaseIndentPattern: new RegExp(\"^((?!\\\\/\\\\/).)*(\\\\{[^}\\\"'`]*|\\\\([^)\\\"'`]*|\\\\[[^\\\\]\\\"'`]*)$\"),\n    decreaseIndentPattern: new RegExp(\"^((?!.*?\\\\/\\\\*).*\\\\*/)?\\\\s*[\\\\}\\\\]].*$\")\n  }\n};\nvar language = {\n  defaultToken: \"\",\n  tokenPostfix: \".proto\",\n  brackets: [{\n    open: \"{\",\n    close: \"}\",\n    token: \"delimiter.curly\"\n  }, {\n    open: \"[\",\n    close: \"]\",\n    token: \"delimiter.square\"\n  }, {\n    open: \"(\",\n    close: \")\",\n    token: \"delimiter.parenthesis\"\n  }, {\n    open: \"<\",\n    close: \">\",\n    token: \"delimiter.angle\"\n  }],\n  symbols: /[=><!~?:&|+\\-*/^%]+/,\n  keywords: [\"syntax\", \"import\", \"weak\", \"public\", \"package\", \"option\", \"repeated\", \"oneof\", \"map\", \"reserved\", \"to\", \"max\", \"enum\", \"message\", \"service\", \"rpc\", \"stream\", \"returns\", \"package\", \"optional\", \"true\", \"false\"],\n  builtinTypes: [\"double\", \"float\", \"int32\", \"int64\", \"uint32\", \"uint64\", \"sint32\", \"sint64\", \"fixed32\", \"fixed64\", \"sfixed32\", \"sfixed64\", \"bool\", \"string\", \"bytes\"],\n  operators: [\"=\", \"+\", \"-\"],\n  namedLiterals,\n  escapes: `\\\\\\\\(u{[0-9A-Fa-f]+}|n|r|t|\\\\\\\\|'|\\\\\\${)`,\n  identifier: /[a-zA-Z]\\w*/,\n  fullIdentifier: /@identifier(?:\\s*\\.\\s*@identifier)*/,\n  optionName: /(?:@identifier|\\(\\s*@fullIdentifier\\s*\\))(?:\\s*\\.\\s*@identifier)*/,\n  messageName: /@identifier/,\n  enumName: /@identifier/,\n  messageType: /\\.?\\s*(?:@identifier\\s*\\.\\s*)*@messageName/,\n  enumType: /\\.?\\s*(?:@identifier\\s*\\.\\s*)*@enumName/,\n  floatLit: /[0-9]+\\s*\\.\\s*[0-9]*(?:@exponent)?|[0-9]+@exponent|\\.[0-9]+(?:@exponent)?/,\n  exponent: /[eE]\\s*[+-]?\\s*[0-9]+/,\n  boolLit: /true\\b|false\\b/,\n  decimalLit: /[1-9][0-9]*/,\n  octalLit: /0[0-7]*/,\n  hexLit: /0[xX][0-9a-fA-F]+/,\n  type: /double|float|int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string|bytes|@messageType|@enumType/,\n  keyType: /int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string/,\n  tokenizer: {\n    root: [{\n      include: \"@whitespace\"\n    }, [/syntax/, \"keyword\"], [/=/, \"operators\"], [/;/, \"delimiter\"], [/(\")(proto3)(\")/, [\"string.quote\", \"string\", {\n      token: \"string.quote\",\n      switchTo: \"@topLevel.proto3\"\n    }]], [/(\")(proto2)(\")/, [\"string.quote\", \"string\", {\n      token: \"string.quote\",\n      switchTo: \"@topLevel.proto2\"\n    }]], [/.*?/, {\n      token: \"\",\n      switchTo: \"@topLevel.proto2\"\n    }]],\n    topLevel: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/=/, \"operators\"], [/[;.]/, \"delimiter\"], [/@fullIdentifier/, {\n      cases: {\n        option: {\n          token: \"keyword\",\n          next: \"@option.$S2\"\n        },\n        enum: {\n          token: \"keyword\",\n          next: \"@enumDecl.$S2\"\n        },\n        message: {\n          token: \"keyword\",\n          next: \"@messageDecl.$S2\"\n        },\n        service: {\n          token: \"keyword\",\n          next: \"@serviceDecl.$S2\"\n        },\n        extend: {\n          cases: {\n            \"$S2==proto2\": {\n              token: \"keyword\",\n              next: \"@extendDecl.$S2\"\n            }\n          }\n        },\n        \"@keywords\": \"keyword\",\n        \"@default\": \"identifier\"\n      }\n    }]],\n    enumDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"type.identifier\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@enumBody.$S2\"\n    }]],\n    enumBody: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/=/, \"operators\"], [/;/, \"delimiter\"], [/option\\b/, \"keyword\", \"@option.$S2\"], [/@identifier/, \"identifier\"], [/\\[/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@options.$S2\"\n    }], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    messageDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"type.identifier\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@messageBody.$S2\"\n    }]],\n    messageBody: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/=/, \"operators\"], [/;/, \"delimiter\"], [\"(map)(s*)(<)\", [\"keyword\", \"white\", {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@map.$S2\"\n    }]], [/@identifier/, {\n      cases: {\n        option: {\n          token: \"keyword\",\n          next: \"@option.$S2\"\n        },\n        enum: {\n          token: \"keyword\",\n          next: \"@enumDecl.$S2\"\n        },\n        message: {\n          token: \"keyword\",\n          next: \"@messageDecl.$S2\"\n        },\n        oneof: {\n          token: \"keyword\",\n          next: \"@oneofDecl.$S2\"\n        },\n        extensions: {\n          cases: {\n            \"$S2==proto2\": {\n              token: \"keyword\",\n              next: \"@reserved.$S2\"\n            }\n          }\n        },\n        reserved: {\n          token: \"keyword\",\n          next: \"@reserved.$S2\"\n        },\n        \"(?:repeated|optional)\": {\n          token: \"keyword\",\n          next: \"@field.$S2\"\n        },\n        required: {\n          cases: {\n            \"$S2==proto2\": {\n              token: \"keyword\",\n              next: \"@field.$S2\"\n            }\n          }\n        },\n        \"$S2==proto3\": {\n          token: \"@rematch\",\n          next: \"@field.$S2\"\n        }\n      }\n    }], [/\\[/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@options.$S2\"\n    }], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    extendDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"type.identifier\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@extendBody.$S2\"\n    }]],\n    extendBody: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/;/, \"delimiter\"], [/(?:repeated|optional|required)/, \"keyword\", \"@field.$S2\"], [/\\[/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@options.$S2\"\n    }], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    options: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/;/, \"delimiter\"], [/@optionName/, \"annotation\"], [/[()]/, \"annotation.brackets\"], [/=/, \"operator\"], [/\\]/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    option: [{\n      include: \"@whitespace\"\n    }, [/@optionName/, \"annotation\"], [/[()]/, \"annotation.brackets\"], [/=/, \"operator\", \"@pop\"]],\n    oneofDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"identifier\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@oneofBody.$S2\"\n    }]],\n    oneofBody: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/;/, \"delimiter\"], [/(@identifier)(\\s*)(=)/, [\"identifier\", \"white\", \"delimiter\"]], [/@fullIdentifier|\\./, {\n      cases: {\n        \"@builtinTypes\": \"keyword\",\n        \"@default\": \"type.identifier\"\n      }\n    }], [/\\[/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@options.$S2\"\n    }], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    reserved: [{\n      include: \"@whitespace\"\n    }, [/,/, \"delimiter\"], [/;/, \"delimiter\", \"@pop\"], {\n      include: \"@constant\"\n    }, [/to\\b|max\\b/, \"keyword\"]],\n    map: [{\n      include: \"@whitespace\"\n    }, [/@fullIdentifier|\\./, {\n      cases: {\n        \"@builtinTypes\": \"keyword\",\n        \"@default\": \"type.identifier\"\n      }\n    }], [/,/, \"delimiter\"], [/>/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      switchTo: \"identifier\"\n    }]],\n    field: [{\n      include: \"@whitespace\"\n    }, [\"group\", {\n      cases: {\n        \"$S2==proto2\": {\n          token: \"keyword\",\n          switchTo: \"@groupDecl.$S2\"\n        }\n      }\n    }], [/(@identifier)(\\s*)(=)/, [\"identifier\", \"white\", {\n      token: \"delimiter\",\n      next: \"@pop\"\n    }]], [/@fullIdentifier|\\./, {\n      cases: {\n        \"@builtinTypes\": \"keyword\",\n        \"@default\": \"type.identifier\"\n      }\n    }]],\n    groupDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"identifier\"], [\"=\", \"operator\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@messageBody.$S2\"\n    }], {\n      include: \"@constant\"\n    }],\n    type: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"type.identifier\", \"@pop\"], [/./, \"delimiter\"]],\n    identifier: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"identifier\", \"@pop\"]],\n    serviceDecl: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"identifier\"], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@serviceBody.$S2\"\n    }]],\n    serviceBody: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/;/, \"delimiter\"], [/option\\b/, \"keyword\", \"@option.$S2\"], [/rpc\\b/, \"keyword\", \"@rpc.$S2\"], [/\\[/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@options.$S2\"\n    }], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    rpc: [{\n      include: \"@whitespace\"\n    }, [/@identifier/, \"identifier\"], [/\\(/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@request.$S2\"\n    }], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@methodOptions.$S2\"\n    }], [/;/, \"delimiter\", \"@pop\"]],\n    request: [{\n      include: \"@whitespace\"\n    }, [/@messageType/, {\n      cases: {\n        stream: {\n          token: \"keyword\",\n          next: \"@type.$S2\"\n        },\n        \"@default\": \"type.identifier\"\n      }\n    }], [/\\)/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      switchTo: \"@returns.$S2\"\n    }]],\n    returns: [{\n      include: \"@whitespace\"\n    }, [/returns\\b/, \"keyword\"], [/\\(/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      switchTo: \"@response.$S2\"\n    }]],\n    response: [{\n      include: \"@whitespace\"\n    }, [/@messageType/, {\n      cases: {\n        stream: {\n          token: \"keyword\",\n          next: \"@type.$S2\"\n        },\n        \"@default\": \"type.identifier\"\n      }\n    }], [/\\)/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      switchTo: \"@rpc.$S2\"\n    }]],\n    methodOptions: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/;/, \"delimiter\"], [\"option\", \"keyword\"], [/@optionName/, \"annotation\"], [/[()]/, \"annotation.brackets\"], [/=/, \"operator\"], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    comment: [[/[^\\/*]+/, \"comment\"], [/\\/\\*/, \"comment\", \"@push\"], [\"\\\\*/\", \"comment\", \"@pop\"], [/[\\/*]/, \"comment\"]],\n    string: [[/[^\\\\\"]+/, \"string\"], [/@escapes/, \"string.escape\"], [/\\\\./, \"string.escape.invalid\"], [/\"/, {\n      token: \"string.quote\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    stringSingle: [[/[^\\\\']+/, \"string\"], [/@escapes/, \"string.escape\"], [/\\\\./, \"string.escape.invalid\"], [/'/, {\n      token: \"string.quote\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]],\n    constant: [[\"@boolLit\", \"keyword.constant\"], [\"@hexLit\", \"number.hex\"], [\"@octalLit\", \"number.octal\"], [\"@decimalLit\", \"number\"], [\"@floatLit\", \"number.float\"], [/(\"([^\"\\\\]|\\\\.)*|'([^'\\\\]|\\\\.)*)$/, \"string.invalid\"], [/\"/, {\n      token: \"string.quote\",\n      bracket: \"@open\",\n      next: \"@string\"\n    }], [/'/, {\n      token: \"string.quote\",\n      bracket: \"@open\",\n      next: \"@stringSingle\"\n    }], [/{/, {\n      token: \"@brackets\",\n      bracket: \"@open\",\n      next: \"@prototext\"\n    }], [/identifier/, \"identifier\"]],\n    whitespace: [[/[ \\t\\r\\n]+/, \"white\"], [/\\/\\*/, \"comment\", \"@comment\"], [/\\/\\/.*$/, \"comment\"]],\n    prototext: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@constant\"\n    }, [/@identifier/, \"identifier\"], [/[:;]/, \"delimiter\"], [/}/, {\n      token: \"@brackets\",\n      bracket: \"@close\",\n      next: \"@pop\"\n    }]]\n  }\n};\n\n\n//# sourceURL=webpack://online-conplier/./node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.js?");

/***/ })

}]);