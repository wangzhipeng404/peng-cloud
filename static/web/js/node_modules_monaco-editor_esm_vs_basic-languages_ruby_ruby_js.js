"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkonline_conplier"] = self["webpackChunkonline_conplier"] || []).push([["node_modules_monaco-editor_esm_vs_basic-languages_ruby_ruby_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"conf\": function() { return /* binding */ conf; },\n/* harmony export */   \"language\": function() { return /* binding */ language; }\n/* harmony export */ });\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n// src/basic-languages/ruby/ruby.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\",\n    blockComment: [\"=begin\", \"=end\"]\n  },\n  brackets: [[\"(\", \")\"], [\"{\", \"}\"], [\"[\", \"]\"]],\n  autoClosingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }],\n  surroundingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }],\n  indentationRules: {\n    increaseIndentPattern: new RegExp(`^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\"|'|/).*\\\\4)*(#.*)?$`),\n    decreaseIndentPattern: new RegExp(\"^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)\")\n  }\n};\nvar language = {\n  tokenPostfix: \".ruby\",\n  keywords: [\"__LINE__\", \"__ENCODING__\", \"__FILE__\", \"BEGIN\", \"END\", \"alias\", \"and\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"for\", \"false\", \"if\", \"in\", \"module\", \"next\", \"nil\", \"not\", \"or\", \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\", \"until\", \"when\", \"while\", \"yield\"],\n  keywordops: [\"::\", \"..\", \"...\", \"?\", \":\", \"=>\"],\n  builtins: [\"require\", \"public\", \"private\", \"include\", \"extend\", \"attr_reader\", \"protected\", \"private_class_method\", \"protected_class_method\", \"new\"],\n  declarations: [\"module\", \"class\", \"def\", \"case\", \"do\", \"begin\", \"for\", \"if\", \"while\", \"until\", \"unless\"],\n  linedecls: [\"def\", \"case\", \"do\", \"begin\", \"for\", \"if\", \"while\", \"until\", \"unless\"],\n  operators: [\"^\", \"&\", \"|\", \"<=>\", \"==\", \"===\", \"!~\", \"=~\", \">\", \">=\", \"<\", \"<=\", \"<<\", \">>\", \"+\", \"-\", \"*\", \"/\", \"%\", \"**\", \"~\", \"+@\", \"-@\", \"[]\", \"[]=\", \"`\", \"+=\", \"-=\", \"*=\", \"**=\", \"/=\", \"^=\", \"%=\", \"<<=\", \">>=\", \"&=\", \"&&=\", \"||=\", \"|=\"],\n  brackets: [{\n    open: \"(\",\n    close: \")\",\n    token: \"delimiter.parenthesis\"\n  }, {\n    open: \"{\",\n    close: \"}\",\n    token: \"delimiter.curly\"\n  }, {\n    open: \"[\",\n    close: \"]\",\n    token: \"delimiter.square\"\n  }],\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  tokenizer: {\n    root: [[/^(\\s*)([a-z_]\\w*[!?=]?)/, [\"white\", {\n      cases: {\n        \"for|until|while\": {\n          token: \"keyword.$2\",\n          next: \"@dodecl.$2\"\n        },\n        \"@declarations\": {\n          token: \"keyword.$2\",\n          next: \"@root.$2\"\n        },\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }]], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        \"if|unless|while|until\": {\n          token: \"keyword.$0x\",\n          next: \"@modifier.$0x\"\n        },\n        for: {\n          token: \"keyword.$2\",\n          next: \"@dodecl.$2\"\n        },\n        \"@linedecls\": {\n          token: \"keyword.$0\",\n          next: \"@root.$0\"\n        },\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], [/[A-Z][\\w]*[!?=]?/, \"constructor.identifier\"], [/\\$[\\w]*/, \"global.constant\"], [/@[\\w]*/, \"namespace.instance.identifier\"], [/@@@[\\w]*/, \"namespace.class.identifier\"], [/<<[-~](@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }], [/[ \\t\\r\\n]+<<(@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }], [/^<<(@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }], {\n      include: \"@whitespace\"\n    }, [/\"/, {\n      token: \"string.d.delim\",\n      next: '@dstring.d.\"'\n    }], [/'/, {\n      token: \"string.sq.delim\",\n      next: \"@sstring.sq\"\n    }], [/%([rsqxwW]|Q?)/, {\n      token: \"@rematch\",\n      next: \"pstring\"\n    }], [/`/, {\n      token: \"string.x.delim\",\n      next: \"@dstring.x.`\"\n    }], [/:(\\w|[$@])\\w*[!?=]?/, \"string.s\"], [/:\"/, {\n      token: \"string.s.delim\",\n      next: '@dstring.s.\"'\n    }], [/:'/, {\n      token: \"string.s.delim\",\n      next: \"@sstring.s\"\n    }], [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, {\n      token: \"regexp.delim\",\n      next: \"@regexp\"\n    }], [/[{}()\\[\\]]/, \"@brackets\"], [/@symbols/, {\n      cases: {\n        \"@keywordops\": \"keyword\",\n        \"@operators\": \"operator\",\n        \"@default\": \"\"\n      }\n    }], [/[;,]/, \"delimiter\"], [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, \"number.hex\"], [/0[_oO][0-7](_?[0-7])*/, \"number.octal\"], [/0[bB][01](_?[01])*/, \"number.binary\"], [/0[dD]@decpart/, \"number\"], [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\n      cases: {\n        $1: \"number.float\",\n        \"@default\": \"number\"\n      }\n    }]],\n    dodecl: [[/^/, {\n      token: \"\",\n      switchTo: \"@root.$S2\"\n    }], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        do: {\n          token: \"keyword\",\n          switchTo: \"@root.$S2\"\n        },\n        \"@linedecls\": {\n          token: \"@rematch\",\n          switchTo: \"@root.$S2\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], {\n      include: \"@root\"\n    }],\n    modifier: [[/^/, \"\", \"@pop\"], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        \"then|else|elsif|do\": {\n          token: \"keyword\",\n          switchTo: \"@root.$S2\"\n        },\n        \"@linedecls\": {\n          token: \"@rematch\",\n          switchTo: \"@root.$S2\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], {\n      include: \"@root\"\n    }],\n    sstring: [[/[^\\\\']+/, \"string.$S2\"], [/\\\\\\\\|\\\\'|\\\\$/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.invalid\"], [/'/, {\n      token: \"string.$S2.delim\",\n      next: \"@pop\"\n    }]],\n    dstring: [[/[^\\\\`\"#]+/, \"string.$S2\"], [/#/, \"string.$S2.escape\", \"@interpolated\"], [/\\\\$/, \"string.$S2.escape\"], [/@escapes/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.escape.invalid\"], [/[`\"]/, {\n      cases: {\n        \"$#==$S3\": {\n          token: \"string.$S2.delim\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string.$S2\"\n      }\n    }]],\n    heredoc: [[/^(\\s*)(@heredelim)$/, {\n      cases: {\n        \"$2==$S2\": [\"string.heredoc\", {\n          token: \"string.heredoc.delimiter\",\n          next: \"@pop\"\n        }],\n        \"@default\": [\"string.heredoc\", \"string.heredoc\"]\n      }\n    }], [/.*/, \"string.heredoc\"]],\n    interpolated: [[/\\$\\w*/, \"global.constant\", \"@pop\"], [/@\\w*/, \"namespace.class.identifier\", \"@pop\"], [/@@@\\w*/, \"namespace.instance.identifier\", \"@pop\"], [/[{]/, {\n      token: \"string.escape.curly\",\n      switchTo: \"@interpolated_compound\"\n    }], [\"\", \"\", \"@pop\"]],\n    interpolated_compound: [[/[}]/, {\n      token: \"string.escape.curly\",\n      next: \"@pop\"\n    }], {\n      include: \"@root\"\n    }],\n    pregexp: [{\n      include: \"@whitespace\"\n    }, [/[^\\(\\{\\[\\\\]/, {\n      cases: {\n        \"$#==$S3\": {\n          token: \"regexp.delim\",\n          next: \"@pop\"\n        },\n        \"$#==$S2\": {\n          token: \"regexp.delim\",\n          next: \"@push\"\n        },\n        \"~[)}\\\\]]\": \"@brackets.regexp.escape.control\",\n        \"~@regexpctl\": \"regexp.escape.control\",\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexcontrol\"\n    }],\n    regexp: [{\n      include: \"@regexcontrol\"\n    }, [/[^\\\\\\/]/, \"regexp\"], [\"/[ixmp]*\", {\n      token: \"regexp.delim\"\n    }, \"@pop\"]],\n    regexcontrol: [[/(\\{)(\\d+(?:,\\d*)?)(\\})/, [\"@brackets.regexp.escape.control\", \"regexp.escape.control\", \"@brackets.regexp.escape.control\"]], [/(\\[)(\\^?)/, [\"@brackets.regexp.escape.control\", {\n      token: \"regexp.escape.control\",\n      next: \"@regexrange\"\n    }]], [/(\\()(\\?[:=!])/, [\"@brackets.regexp.escape.control\", \"regexp.escape.control\"]], [/\\(\\?#/, {\n      token: \"regexp.escape.control\",\n      next: \"@regexpcomment\"\n    }], [/[()]/, \"@brackets.regexp.escape.control\"], [/@regexpctl/, \"regexp.escape.control\"], [/\\\\$/, \"regexp.escape\"], [/@regexpesc/, \"regexp.escape\"], [/\\\\\\./, \"regexp.invalid\"], [/#/, \"regexp.escape\", \"@interpolated\"]],\n    regexrange: [[/-/, \"regexp.escape.control\"], [/\\^/, \"regexp.invalid\"], [/\\\\$/, \"regexp.escape\"], [/@regexpesc/, \"regexp.escape\"], [/[^\\]]/, \"regexp\"], [/\\]/, \"@brackets.regexp.escape.control\", \"@pop\"]],\n    regexpcomment: [[/[^)]+/, \"comment\"], [/\\)/, {\n      token: \"regexp.escape.control\",\n      next: \"@pop\"\n    }]],\n    pstring: [[/%([qws])\\(/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.(.)\"\n    }], [/%([qws])\\[/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.[.]\"\n    }], [/%([qws])\\{/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.{.}\"\n    }], [/%([qws])</, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.<.>\"\n    }], [/%([qws])(@delim)/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.$2.$2\"\n    }], [/%r\\(/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.(.)\"\n    }], [/%r\\[/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.[.]\"\n    }], [/%r\\{/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.{.}\"\n    }], [/%r</, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.<.>\"\n    }], [/%r(@delim)/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.$1.$1\"\n    }], [/%(x|W|Q?)\\(/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.(.)\"\n    }], [/%(x|W|Q?)\\[/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.[.]\"\n    }], [/%(x|W|Q?)\\{/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.{.}\"\n    }], [/%(x|W|Q?)</, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.<.>\"\n    }], [/%(x|W|Q?)(@delim)/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.$2.$2\"\n    }], [/%([rqwsxW]|Q?)./, {\n      token: \"invalid\",\n      next: \"@pop\"\n    }], [/./, {\n      token: \"invalid\",\n      next: \"@pop\"\n    }]],\n    qstring: [[/\\\\$/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.escape\"], [/./, {\n      cases: {\n        \"$#==$S4\": {\n          token: \"string.$S2.delim\",\n          next: \"@pop\"\n        },\n        \"$#==$S3\": {\n          token: \"string.$S2.delim\",\n          next: \"@push\"\n        },\n        \"@default\": \"string.$S2\"\n      }\n    }]],\n    qqstring: [[/#/, \"string.$S2.escape\", \"@interpolated\"], {\n      include: \"@qstring\"\n    }],\n    whitespace: [[/[ \\t\\r\\n]+/, \"\"], [/^\\s*=begin\\b/, \"comment\", \"@comment\"], [/#.*$/, \"comment\"]],\n    comment: [[/[^=]+/, \"comment\"], [/^\\s*=begin\\b/, \"comment.invalid\"], [/^\\s*=end\\b.*/, \"comment\", \"@pop\"], [/[=]/, \"comment\"]]\n  }\n};\n\n\n//# sourceURL=webpack://online-conplier/./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js?");

/***/ })

}]);